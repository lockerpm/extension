<template>
  <div
    class="relative mx-auto"
    v-loading="loading"
  >
    <NoCipher
      v-if="shouldRenderNoCipher && !$store.state.syncing"
      :type="folder ? 'folder_item' : type"
      @add-cipher="addCipher"
    />
    <div v-else>
      <SortMenu
        :ciphers="ciphers"
        :label="folder ? $t('data.parts.folder_items') : $tc(`type.${type}`, 2)"
        :order-field="orderField"
        :order-direction="orderDirection"
        @sort="changeSort"
      />
      <ul class="list-ciphers">
        <cipher-row
          v-for="item in (pagingCiphers || [])"
          :key="item.id"
          :item="item"
          :folder="folder"
          @do-fill="$emit('do-fill', item)"
        >
        </cipher-row>
      </ul>
    </div>
  </div>
</template>

<script>
import Vue from "vue";
import orderBy from "lodash/orderBy";
import NoCipher from "@/popup/components/ciphers/NoCipher";
import CipherRow from "@/popup/components/ciphers/CipherRow";
import SortMenu from "@/components/SortMenu.vue";

import { CipherType } from "jslib-common/enums/cipherType";

export default Vue.extend({
  components: {
    NoCipher,
    CipherRow,
    SortMenu,
  },
  props: {
    deleted: {
      type: Boolean,
      default: false,
    },
    type: {
      type: Number,
      default: 1,
    },
    folder: {
      type: Object,
      default: null
    }
  },
  data() {
    return {
      CipherType,
      orderField: "revisionDate",
      orderDirection: "desc",
      loading: false,
      pageSize: 10,
      size: 10
    };
  },
  asyncComputed: {
    ciphers: {
      async get() {
        this.loading = true
        const deletedFilter = (c) => {
          return c.isDeleted === this.deleted;
        };
        let result =
          (await this.$searchService.searchCiphers(
            this.searchText,
            [...this.cipherFilters, deletedFilter],
            null
          )) || [];
        // remove ciphers generated by authenticator
        result = result.filter((cipher) =>
          [
            CipherType.Login,
            CipherType.SecureNote,
            CipherType.Card,
            CipherType.Identity,
            CipherType.CryptoAccount,
            CipherType.CryptoWallet,
          ].includes(cipher.type)
        );
        result.map((item) => {
          if (item.type === CipherType.CryptoAccount) {
            try {
              item.cryptoAccount = JSON.parse(item.notes);
            // eslint-disable-next-line no-empty
            } catch (error) {}
          }
          if (item.type === CipherType.CryptoWallet) {
            try {
              item.cryptoWallet = JSON.parse(item.notes);
            // eslint-disable-next-line no-empty
            } catch (error) {}
          }
          return {
            ...item,
            checked: false,
          };
        });
        result = orderBy(result, [c => this.orderField === 'name' ? (c.name && c.name.toLowerCase()) : c.revisionDate], [this.orderDirection]) || []
        this.loading = false
        return result
      },
      watch: [
        "$store.state.syncedCiphersToggle",
        "deleted",
        "searchText",
        "type",
        "orderField",
        "orderDirection",
        "folder"
      ],
    }
  },
  computed: {
    orderString() {
      return `${this.orderField}_${this.orderDirection}`;
    },
    shouldRenderNoCipher() {
      if (this.ciphers) {
        return !this.ciphers.length;
      }
      return false
    },
    cipherFilters() {
      const filters = []
      if (this.type == CipherType.CryptoBackup) {
        filters.push((c) => c.type ===  CipherType.CryptoAccount || c.type === CipherType.CryptoWallet)
      } else {
        filters.push((c) => c.type === this.type)
      }
      if (this.folder) {
        filters.push((c) => c.folderId === this.folder.id)
      }
      return filters
    },
    pagingCiphers() {
      if (this.ciphers) {
        return this.ciphers.slice(0, this.size)
      }
      return []
    },
  },
  watch: {
    type: 'typeChanged'
  },
  mounted () {
    const mainBody = document.querySelector('.main-body')
    if (mainBody) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const self = this
      mainBody.addEventListener('scrollend', () => {
        if (self.ciphers && self.ciphers.length > self.size) {
          self.size = self.pageSize + self.size
        }
      })
    }
  },
  methods: {
    changeSort(sortValue) {
      this.orderField = sortValue.orderField;
      this.orderDirection = sortValue.orderDirection;
    },
    addCipher() {
      this.$router.push({
        name: "add-edit-cipher",
        params: { type: this.type || CipherType.Login, folder: this.folder },
      });
    },
    typeChanged() {
      const mainBody = document.querySelector('.main-body')
      if (mainBody) {
        mainBody.scrollTo({ top: 0, behavior: 'smooth' })
      }
      setTimeout(() => {
        this.size = this.pageSize
      }, 1000);
    }
  },
});
</script>
