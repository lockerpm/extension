<template>
  <div
    class="relative mx-auto"
  >
    <NoCipher
      v-if="shouldRenderNoCipher && !$store.state.syncing"
      :type="folderId ? 'folder_item' : type"
      @add-cipher="handleAddButton"
    />
    <div v-else>
      <SortMenu
        :ciphers="ciphers"
        :label="folderId ? $t('data.parts.folder_items') : $tc(`type.${type}`, 2)"
        :order-field="orderField"
        :order-direction="orderDirection"
        @sort="changeSort"
      />
      <ul class="list-ciphers">
        <cipher-row
          v-for="item in dataRendered"
          :key="item.id"
          :item="item"
          @do-fill="$emit('do-fill', item)"
        >
        </cipher-row>
      </ul>
    </div>
  </div>
</template>

<script>
import Vue from "vue";
import orderBy from "lodash/orderBy";
import NoCipher from "@/popup/components/ciphers/NoCipher";
import CipherRow from "@/popup/components/ciphers/CipherRow";
import SortMenu from "@/components/SortMenu.vue";

import { CipherType } from "jslib-common/enums/cipherType";

const BroadcasterSubscriptionId = "ChildViewComponent";

export default Vue.extend({
  components: {
    NoCipher,
    CipherRow,
    SortMenu,
  },
  props: {
    deleted: {
      type: Boolean,
      default: false,
    },
    type: {
      type: Number,
      default: 1,
    },
    folderId: {
      type: String,
      default: ''
    }
  },
  data() {
    return {
      CipherType,
      dataRendered: [],
      renderIndex: 0,
      pageDetails: [],
      orderField: "revisionDate",
      orderDirection: "desc",
    };
  },
  async mounted() {
    self.onscroll = () => {
      const bottomOfWindow =
        Math.max(
          self.pageYOffset,
          document.documentElement.scrollTop,
          document.body.scrollTop
        ) +
          self.innerHeight +
          500 >=
        document.documentElement.scrollHeight;

      if (bottomOfWindow) {
        this.renderIndex += 50;
        if ( this.ciphers && this.renderIndex <= this.ciphers.length) {
          this.dataRendered = this.dataRendered.concat(
            this.ciphers.slice(this.renderIndex, this.renderIndex + 50)
          );
        }
      }
    };
    chrome.runtime.onMessage.addListener(
      (msg, sender, response) => {
        switch (msg.command) {
        case "collectPageDetailsResponse":
          if (msg.sender === BroadcasterSubscriptionId) {
            const pageDetailsObj = {
              frameId: sender.frameId,
              tab: msg.tab,
              details: msg.details,
            };
            this.pageDetails.push(pageDetailsObj);
            response()
          }
          break;
        default:
          break;
        }
      }
    );
  },
  computed: {
    orderString() {
      return `${this.orderField}_${this.orderDirection}`;
    },
    shouldRenderNoCipher() {
      const filteredCiphers = this.ciphers || [];
      return !filteredCiphers.length;
    },
    cipherFilter() {
      if (this.folderId) {
        return (c) => c.folderId === this.folderId
      }
      if (this.type == CipherType.CryptoBackup) {
        return (c) => c.type ===  CipherType.CryptoAccount || c.type === CipherType.CryptoWallet
      }
      return (c) => c.type === this.type
    }
  },
  asyncComputed: {
    ciphers: {
      async get() {
        const deletedFilter = (c) => {
          return c.isDeleted === this.deleted;
        };
        let result =
          (await this.$searchService.searchCiphers(
            this.searchText,
            [this.cipherFilter, deletedFilter],
            null
          )) || [];
        // remove ciphers generated by authenticator
        result = result.filter((cipher) =>
          [
            CipherType.Login,
            CipherType.SecureNote,
            CipherType.Card,
            CipherType.Identity,
            CipherType.CryptoAccount,
            CipherType.CryptoWallet,
          ].includes(cipher.type)
        );
        result.map((item) => {
          if (item.type === CipherType.CryptoAccount) {
            try {
              item.cryptoAccount = JSON.parse(item.notes);
            // eslint-disable-next-line no-empty
            } catch (error) {}
          }
          if (item.type === CipherType.CryptoWallet) {
            try {
              item.cryptoWallet = JSON.parse(item.notes);
            // eslint-disable-next-line no-empty
            } catch (error) {}
          }
          return {
            ...item,
            checked: false,
          };
        });
        result = orderBy(result, [c => this.orderField === 'name' ? (c.name && c.name.toLowerCase()) : c.revisionDate], [this.orderDirection]) || []
        this.dataRendered = result.slice(0, 50);
        this.renderIndex = 0;
        return result
      },
      watch: [
        "$store.state.syncedCiphersToggle",
        "deleted",
        "searchText",
        "type",
        "orderField",
        "orderDirection",
      ],
    }
  },
  methods: {
    changeSort(sortValue) {
      this.orderField = sortValue.orderField;
      this.orderDirection = sortValue.orderDirection;
    },
    handleAddButton() {
      this.$router.push({
        name: "add-edit-cipher",
        params: { type: this.type || CipherType.Login, folderId: this.folderId },
      });
    }
  },
});
</script>
